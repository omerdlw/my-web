Veri Yapıları ve Algoritmalar II Dersi Vize Notları

----- SIRALAMALAR -----

TANIM:
Sıralama algoritması, aynı türde verilerden oluşan bir veri kümesini girdi olarak alan ve verileri büyükten küçüğe veya küçükten büyüğe sıralayarak aynı büyüklükte çıktı üreten algoritmadır.

Bir veri dizisinin tamamı ana bellege yazılabiliyor ise, sıralama işlemi ana bellek üzerinde hızlı bir şekilde yapılabilir. Bu sıralamaya dahili sıralama denir.

Sıralanacak olan veri dizisi ana belleğe sığmayacak kadar büyükse tüm veri tek seferde belleğe
yerleştirilemez. Bu durumda veri dizisi harici bellek (sabitdisk, usb bellek, hafıza kartı vb.) üzerinde sıralanır.

Bu sıralamaya harici sıralama denir. Harici sıralama yöntemlerinde veri dizisinin bir kısmı ana bellege alınarak sıralanır ve harici bellege geri yazılır. Bu işlem tüm veri dizisi sıralanana kadar tekrarlanır. Okuma yazma aşamasında zaman kaybı olması ve harici bellegin ana bellege nazaran yavaş olması nedeniyle harici sıralama yöntemleri dahili sıralamaya göre yavaştır, ancak büyük veri kümeleri için uygulanmak zorundadır.

SINIFLANDIRMA KRITERLERI

Sıralama algoritmalarını sınıflandırmak için 5 kriter kullanılır:

1. Hesaplama karmaşıklığı: Sıralama işleminin başarımını matematiksel olarak ifade etmektir. Bir başka deyişle, seçilen algoritmanın veri dizisi için en iyi, en kötü ve ortalama başarımının eleman sayısı (n) cinsinden ifadesidir. Bir sıralama algoritması için en iyi karmaşıklık O(n), ortalama karmaşıklık O(nlogn) ve en kötü karmaşıklık O(n2) olarak belirtilir.

2. Yer değiştirme karmaşıklığı: Sıralama algoritmasının gerçekleştirdiği yer değiştirme sayısını
ifade eder.

3. Bellek kullanımı: Ana bellekteki dizinin sıralanması için ek bir bellek alanına gereksinim
duyulması ile ilgili kriterdir.

4. Rekürsiflik: Özyinelemeli algoritmalar için kullanılan bir kriterdir.

5. Kararlılık: Veri dizisi içerisinde aynı elemanın birden fazla sayıda bulunması durumunda, bu elemanların girdi verisi ile çıktı verisinde aynı ardışıklıkta sıralanması durumudur. Kararlı sıralama algoritmalarına örnek olarak; kabarcık, yerleştirmeli ve birleştirmeli sıralama algoritmaları verilebilir. Hızlı sıralama ise kararsız sıralama algoritmalarına örnektir.

1) KABARCIK SIRALAMA (BUBBLE SORT)

Aynı türde elemanları olan bir veri kümesini sıralama işlemini yapan en basit algoritma kabarcık
sıralama (bubble sort) algoritmasıdır. Adını kabarcıkların su yüzeyine çıkışından almıştır.

Bu algoritma, sayı dizisinin başından başlar ve sırayla dizi elemanlarını seçer. Seçilen eleman kendinden sonraki eleman ile karşılaştırılır ve daha büyükse onunla yer değiştirilir. Bu işlem dizinin son elemanı seçilene kadar sürdürülür ve sonunda dizi sıralanmış olur.

Sıralanacak eleman sayısı n için algoritma karmaşıklığı: (Tablo)

En kötü durum: O(n2) karşılaştırma, O(n2) takas
En iyi durum: O(n2) karşılaştırma, O(1) takas
Ortalama performans: O(n2) karşılaştırma, O(n2) takas

Kabarcık sıralama algoritması diğer sıralama algoritmalarına kıyasla hızlı bir algoritma değildir. En
kötü durumda (dizinin ters sıralanmış olması) en yavaş sıralama algoritmasıdır.

Büyük veri kümelerinde tercih edilmez.

Algoritma örneği:

for (i = O; i < n; i++)
    for (j = 0: j < n - 1; j++)
        if (dizi[i] > dizi[j + 1])
            takas(dizi[j], dizi[j + 1])

2) SEÇMELI SIRALAMA (SELECTION SORT)

Seçmeli sıralama algoritması, en küçük elemanı bulup baştaki elemanla yer değiştirme yöntemi ile çalışır.

Algoritma adımları aşağıdaki şekildedir:

1. Bir elemandan başlayıp ilerleyerek dizideki en küçük elemanı bul.
2. İlk konumdaki eleman ile en küçük elemanı yer değiştir.
3. Dizinin sonuna ulaşana kadar bir sonraki elemandan başlayarak ilk 2 adımı tekrarla.

Sıralanacak eleman sayısı "n" için algoritma karmaşıklığı tablodaki gibidir: (Tablo)

En kötü durum: O(n2) karşılaştırma, O(n) takas
En iyi durum: O(n2) karşılaştırma, O(1) takas
Ortalama performans: O(n2) karşılaştırma, O(n) takas

Seçmeli sıralama algoritması büyük veri kümeleri üzerinde verimli değildir. Ancak bazı durumlarda daha karmaşık algoritmalardan daha iyi sonuç verdiği için tercih edilmektedir.

Algoritma örneği:

for (i = 0; i < n - 1; i++)
    min = i
    for (j = i + 1; j < n; j++)
        if (dizi[i] < dizi[min])
        min = j
    if (min != i)
        takas(dizi[i], dizi[min])

3) YERLESTIRMELI SIRALAMA (INSERTION SORT)

Genellikle yerleştirmeli sıralama veya eklemeli sıralama olarak adlandırılan bu sıralama algoritması, oyuncunun oyun kartlarını elinde sıralamasına benzer şekilde çalışır.

Küçük veri kümelerinde verimli çalışır ve uygulaması kolaydır. Ancak büyük veri kümelerinde hızlı sıralama, birleştirmeli sıralama gibi algoritmalara göre başarısızdır.

Sıralanacak olan dizi, sıralanmış ve sıralanmamış olmak üzere iki parça olarak ele alınır ve her seferinde sıralanmamış diziden bir eleman alınarak sıralanmış dizideki doğru yere yerleştirilir.

Sıralanacak eleman sayısı "n" için algoritma karmaşıklığı tablodaki gibidir: (Tablo)

En kötü durum: O(n2) karşılaştırma, O(n) takas
En iyi durum: O(n2) karşılaştırma, O(1) takas
Ortalama performans: O(n2) karşılaştırma, O(n) takas

Önceden sıralanmış bir diziye rasgele bir eleman eklemek için uygun bir algoritmadır. Yerleştirmeli sıralama ile eleman ekleme durumunda zaman karmaşıklığı O(n) iken, önce elemanı ekleyip sona sıralama durumunda zaman karmaşıklığı O(n2) olacaktır.

Algoritma örneği:

for (i = 1; i < n; i++)
    anahtar = dizi[i]
    j = i - 1
    while (j >= 0 && dizi[j] > anahtar)
        dizi[j + 1] = dizi[i]
        j= j - 1
    dizi[j + 1] = anahtar

4) KABUK SIRALAMA (SHELL SORT)

Kabuk sıralama (Shell sort) algoritması, 1959 yılında Donald Shell tarafından yayınlanmıştır.
Yerleştirmeli sıralama algoritmasının gelişmiş modelidir. Yerleştirmeli sıralama algoritmasındaki kaydırma işlemlerini önlediği için büyük veri kümelerinde genelde daha verimlidir.

Algoritma, birbirinden uzaktaki öğe çiftlerini sıralayarak başlar ve her defasında aradaki boşluğu azaltarak aynı sıralamayı tekrarlar. Aradaki boşluk başlangıçta eleman sayısının yarısı olarak başlar ve her defasında yarıya bölünerek ilerler. Eleman sayısı "n" ve aralık (gap yada interval) büyüklüğü "a" olmak üzere:

a = n/2, n/4, n/8, ..., 1

Sıralanacak eleman sayısı "n" için algoritma karmaşıklığı tablodaki şekildedir: (Tablo)

En kötü durum: O(n2)
En iyi durum: O(nlogn)
Ortalama performans: O(nlogn)

Kabuk sıralamanın zaman karmaşıklığı aralık (gap yada interval) büyüklüğüne bağlıdır. Sıralanacak bir veri kümesi için en iyi artış aralık sayısı önceden kestirilemez.

Algoritma örneği:

for (a = n / 2; a > 0; a /= 2)
    for (i = a; i < n; i++)
        temp = dizi[i]
        for (j = i; j »= a && dizi[j - a] > temp; j -= a)
            dizi[i] = dizi[j - a]
        dizi[j] = temp

5) HIZLI SIRALAMA (QUICK SORT)

Hızlı sıralama (quick sort) algoritması 1960 yılında C.A.R. Hoare tarafından geliştirilmiştir.

Hızlı sıralama algoritması, sıralanacak bir sayı dizisini daha küçük iki parçaya ayırıp oluşan bu küçük parçaların kendi içinde sıralanması mantığıyla çalışır. Özyinelemeli (recursive) bir algoritmadır.

Algoritmanın adımları aşağıdaki gibidir:
1. Sayı dizisinden herhangi bir sayıyı pivot eleman olarak seç.
2. Sayı dizisini pivottan küçük olan tüm sayılar pivotun soluna, pivottan büyük olan tüm sayılar pivotun sağına gelecek biçimde düzenle (Algoritmanın bu aşamasına bölümlendirme aşaması denir.)
3. Bölümlendirme sonucunda pivotun sol ve sağ tarafında olmak üzere oluşan iyi ayrı alt dizi
üzerinde yeniden hızlı sıralama algoritmasını çalıştır.

Algoritma, içinde sayı kalmayan (eleman sayısı sıfır olan) bir alt diziye ulaştığında bu dizinin sıralı olduğunu varsayar.

Genelde sıralama algoritmaları için en kötü zaman karmaşıklığı dizinin ters sıralanmış olması durumunda hesaplanır. Hızlı sıralamada ise tüm elemanların eşit olması veya pivot elemanın dizinin en küçük veya en büyük elemanı seçilmesi durumunda en kötü zaman karmaşıklığı hesaplanır.

n elemanlı dizide tüm elemanların birbirinden farklı olması durumunda ortalama zaman
karmaşıklığının O(nlogn) olarak hesaplanması beklenir.

Sıralanacak eleman sayısı "n" için algoritma karmaşıklığı tablodaki şekildedir: (Tablo)

En kötü durum: O(n2)
En iyi durum: O(nlogn)
Ortalama performans: O(nlogn)

Bölümlendirme fonksiyonu: Bölümlendirme fonksiyonu parametre olarak diziyi, dizinin en küçük indeks numarasını ve en
büyük indeks numarasını alır. Fonksiyon dizinin son elemanını pivot olarak seçer ve pivottan küçük elemanları başa, büyük elemanları sona yerleştirdikten sonra pivotu uygun yere yerleştirir ve pivotun yerleştiği indeks numarasını geri döndürür.

int bolumlendir(dizi[], kucuk, buyuk)
    pivot = dizi[buyuk] -> Pivot elemanı seç
    i = kucuk - 1
    for(j = kucuk; j <= buyuk - 1; j++)
        if (dizi[j] « pivot) -> Sıradaki eleman pivottan küçükse yer değiştir
        i++
        takas(dizi[i] , dizi[j])
    takas(dizi[i + 1], dizi[buyuk]) -> Pivotu yerine koy
    return (i + 1)

Sıralama fonksiyonu: Sıralama fonksiyonu bölümlendirme fonksiyonun döndürdüğü indeks bilgisine göre diziyi iki parça
olarak ele alır. Buna göre indeksin solundaki dizi sıralanmamış küçük alt dizi, indeksin sağındaki dizi de sıralanmamış büyük alt dizidir.

void sirala(dizi[], kucuk, buyuk)
    if(kucuk < buyuk)
        int bi = bolumlendir(dizi[], kucuk, buyuk) -> Bölümlendirme indeksini bul
        sirala(dizi, kucuk, bi - 1)
        sirala(dizi, bi + 1, buyuk)

Algoritma örneği:

int bolumlendir(dizi[], kucuk, buyuk)
    pivot = dizi[buyuk] -> Pivot elemanı seç
    i = kucuk - 1
    for(j = kucuk; j <= buyuk - 1; j++)
        if (dizi[j] « pivot) -> Sıradaki eleman pivottan küçükse yer değiştir
        i++
        takas(dizi[i] , dizi[j])
    takas(dizi[i + 1], dizi[buyuk]) -> Pivotu yerine koy
    return (i + 1)

void sirala(dizi[], kucuk, buyuk)
    if(kucuk < buyuk)
        int bi = bolumlendir(dizi[], kucuk, buyuk) -> Bölümlendirme indeksini bul
        sirala(dizi, kucuk, bi - 1)
        sirala(dizi, bi + 1, buyuk)


----- BAĞLI LİSTE -----

TANIM:

Aynı kümeye ait verilerin birbirlerine sanal olarak bağlanarak bellek üzerine yerleştirildiği doğrusal veri yapısına bağlı liste (linked list) denir.

Bağlı listenin her bir elemanı düğüm (node) olarak adlandırılır ve her düğüm, veri bloğu ve bağlantı bilgisini (adres) içeren iki parçadan oluşur.

İlk düğümü gösteren adrese kök (root, head) denir.
Her düğüm kendinden sonraki düğümün bellek adresini bilmek zorundadır.

Bağlı listenin avantajları:

1. Bağlı liste dinamik bir veri yapısıdır. Yani çalışma zamanında boyutu değiştirilebilir.
2. Listeye yeni bir düğüm eklerken veya mevcut düğümü silerken diğer düğümleri kaydırmak gerekmez.
3. Yığın ve kuyruk gibi veri yapıları bağlı liste kullanılarak uygulanabilir.
4. Yeni bir bağlı liste oluştururken listenin boyutunu bildirmek gerekmez.
5. Bağlı listenin ortasında bir yere kolayca yeni düğüm eklenebilir.

Bağlı listenin dezavantajları:

1. Kullandığı işaretçiler sebebiyle dizi veri yapısına göre daha çok bellek alanı kullanır.
2. Dizilere kıyasla listede arama, sıralama gibi işlemleri yapmak genellikle daha çok zaman alır.
3. Kök adresi kaybedilirse liste kaybedilebilir.
4. Listenin sonuna eklenecek yeni bir düğüm için son düğüme ulaşmak gerekir.

Bağlı listeler yapısına göre üç sınıfa ayrılır;
1. Tek yönlü bağlı liste
2. Çift yönlü bağlı liste
3. Dairesel bağlı liste

Tek yönlü bağlı liste:
Tek yönlü bağlı liste (singly linked list) düğümler arasında tek yönlü bağlantı bulunan bağlı liste
yapısıdır. Her düğüm yalnızca kendinden sonraki düğümün adresini bilir.
Eleman sayısı "n" için arama ve düğüm ekleme işlemlerinin karmaşıklığı O(n)'dir.

Çift yönlü bağlı liste:
Çift yönlü bağlı liste (double linked list) düğümler arasında iki yönlü bağlantı bulunan bağlı liste
yapısıdır. Her düğüm hem kendinden sonraki hem de kendinden önceki düğümün adresini bilir.
Liste üzerinde hem ileri hem de geri hareket edilebildigi için daha esnek bir yapısı vardır. Ancak çift işaretçi kullandığı için bellek maliyeti tek yönlü bağlı listeden büyüktür.
Eleman sayısı "n" için arama ve düğüm ekleme işlemlerinin karmaşıklığı O(n)'dir.

Dairesel bağlı liste:
Dairesel bağlı liste (circular linked list) düğümler arasında tek yönlü bağlantı bulunan ancak son
düğümün yine ilk düğüme bağlı olduğu bağlı liste yapısıdır.
"n" düğümlü dairesel bağlı listede "n" defa ilerlenirse ilk düğüme dönülür.
Dairesel bağlı listede herhangi bir düğümün adresi bilindiği takdirde tüm düğümlere erişilebilir.

Bağlı liste oluşturma:
Bir bağlı liste oluşturmak için o listenin her düğümünü ifade eden bir yapı tanımlanır.

Örnek tek yönlü bağlı liste yapısı:

struct dugum
    int Okul no
    char ad [10]
    int bolum_ID
    float puan
    dugum *sonraki

Örnek çift yönlü bağlı liste yapısı:

struct dugum
    int Okul no
    char ad[10]
    int bolum_ID
    float puan
    dugum *onceki
    dugum *sonraki

Bir düğümün bellekteki boyutu; veri bloğundaki verilerin toplam boyutu ve adres bloğundaki adres boyutunun toplamına eşittir.
Adres verisinin büyüklüğü işletim sistemi mimarisi (32bit, 64bit vb.) ile ilgilidir.

Gösterici kullanımı:

Bir bağlı listeye yeni bir düğüm ekleme işleminde en büyük zorluk listenin boş olması durumu ile listede yalnız bir düğüm olması durumunun ayırt edilememesidir. Çünkü her iki durumda da kök işaretçisinin sonraki değeri NULL olabilir.

Bağlı listeye yeni bir düğüm ekleme işlemi mutlaka listenin sonuna yapılmak zorunda değildir.
Örneğin listenin 302. ve 303. düğümünün arasına yeni bir düğüm yerleştirilmek istenebilir. Bu durumda 302. düğüme kadar sırayla ilerlemek gerekecektir.

Bağlı listede bir eleman aramak için her defasında baştan sona doğru ilerlemek gerekir. Aranan
eleman ortada bir yerde veya sonda olabilir.

Bu problemlerin çözümü için bir yer gösterici işaretçi (iterator) kullanmak en pratik yaklaşımdır.

Yer gösterici kullanmadan listenin sonuna düğüm eklemek için "n" elemanlı bağlı listede "n" defa ilerlemek gerekir. Fonksiyona parametre olarak eklenecek düğümün veri bloğu ve listenin kök adresi gönderilir.

Yer gösterici kullanarak listenin sonuna düğüm eklemek için yer göstericiye listenin son düğümünün adresi atanır. Fonksiyona parametre olarak listenin kök adresi, eklenecek düğümün veri bloğu ve yer gösterici gönderilir. Fonksiyon geriye son elemanın adresini döndürür.

Yer gösterici kullanmadan listenin sonundan düğüm silmek için "n" elemanlı bağlı listede "n" defa ilerlemek gerekir. Fonksiyona parametre olarak listenin kök adresi gönderilir.

Yer gösterici kullanarak listenin sonundan düğüm silmek için yer göstericiye listenin son düğümünün adresi atanır. Fonksiyona parametre olarak listenin kök adresi ve yer gösterici işaretçi gönderilir. Tek yönlü bağlı listede geri geri gitmek mümkün olmadığı için silme işleminden sonra göstericinin değeri NULL olur.

Tek yönlü bağlı listeye düğüm ekleme:

dugum *ekle(dugum *kok, dugum *gosterici, int veri)
    if (gosterici = NULL)
        kok -> ID = veri
        kok -> sonraki = NULL
        return kok
    else if (gosterici -> sonraki = NULL)
        dugum *yeni = new dugum
        gosterici -> sonraki = yeni
        yeni -> ID = veri
        yeni -> sonraki = NULL
        return gosterici -> sonraki
    else
        dugum *yeni = new dugum
        yeni -> sonraki = gosterici →> sonraki
        gosterici -> sonraki = yeni
        yeni -> ID = veri

Çift yönlü bağlı listeye düğüm ekleme:

dugum *ekle(dugum *kok, dugum *gosterici, int veri)
    if (gosterici = NULL)
        kok -> ID = veri
        kok -> sonraki = NULL
        kok -> onceki = kok
        return kok
    else if(gosterici -> sonraki = NULL)
        dugum *yeni = new dugum
        gosterici -> sonraki = yeni
        yeni -> ID = veri
        yeni -> sonraki = NULL
        yeni -> onceki = gosterici
    else
        dugum *yeni = new dugum
        yeni -> sonraki = gosterici -> sonraki
        yeni -> sonraki -> onceki = yeni
        yeni -> onceki = gosterici
        gosterici -> sonraki = yeni
        yeni -> ID = veri
    return gosterici -> sonraki

Dairesel bağlı listeye düğüm ekleme

dugum *ekle(dugum *kok, dugum *gosterici, int veri)
    if (gosterici = NULL)
        kok -> ID = veri
        kok -> sonraki = kok
        return kok
    else
        dugum *yeni = new dugum
        yeni -> sonraki = gosterici →> sonraki
        gosterici -> sonraki = yeni
        yeni -> ID = veri


----- YIĞIN -----

TANIM:

Aynı tip veriler kümesinin düzenli bir şekilde tutulması için dizi, bağlı liste gibi doğrusal veri yapıları kullanılır. Bu veri yapılarında dizinin veya bağlı listenin istenilen sırasına yeni veri ekleme, istenen bir veriyi çıkarma işlemini yapmak mümkündür.

Yığın (stack) veri yapısında, yeni eleman ekleme ve çıkarma işlemi LIFO (Last In First Out/Son giren ilk çıkar) kuralı ile gerçekleşir. Yani yığına her zaman son eklenen eleman ilk önce çıkartılır.

En basit küme veri yapılarındandır ancak işlemci, bellek organizasyonunda ve yazılım geliştirmede çok sık kullanılır. Ayrıca web tarayıcılarının veya dosya yöneticisinin ileri geri butonları, geri alma (undo) işlevleri, polinom çözümü, aritmetik işlem çözümü, labirent çözümü, Hanoi kuleleri çözümü gibi çok sayıda uygulamada kullanılır.

Yığın veri yapısı üst üste yığılmış bir kitap kümesine benzetilebilir.
Kümeye yeni bir kitap eklenmek istenirse sadece en üste eklenebilir.
Kümeden bir kitap alınmak istenirse sadece en üstten (yığına son eklenen) alınabilir.
Yiğının altındaki kitaplardan birini almak için önce üstteki kitapları yığından çıkarmak gerekir.

Yığın fonksiyonları:
Yığınlar üzerinde aşağıdaki fonksiyonlar çalıştırılabilir.

1. createStack() fonksiyonu istenilen boyutta yeni bir yığın oluşturur.
2. isFull( fonksiyonu yığın dolu ise True, dolu degilse False deger döndürür.
3. push() fonksiyonu parametre olarak aldığı elemanı yığının en üstüne ekler. Ekleme işlemi gerçekleştiyse True değer döndürür.
4. isEmpty() fonksiyonu yığın boş ise True, boş değilse False değer döndürür.
5. peek() fonksiyonu yığının en üst elemanını yığından çıkarmadan döndürür veya ekrana yazdırır.
6. display() fonksiyonu yığının tüm elemanlarını ekrana yazdırır.
7. pop() fonksiyonu yığının en üstündeki elemanı yığından çıkarır. Çıkarma gerçekleştiyse true değer döndürür.

Yığının bellekteki ifadesi:
Bir yığın veri yapısı; dizi veya bağlı liste kullanarak oluşturulabilir.
Her iki yaklaşımda da yığının son eklenen elemanın indeksini veya adresini tutan bir üst (top, stack pointer) değişkeni tutulur.
Bazı tasarımlarda yığın boyutu (stack size) da bir değişkende tutulabilir.

Kriter / Dizi / Bağlı liste (Tablo)

Boyut / Ön tanımlıdır. Çalışma zamanında değiştirilemez. / Boyutu her zaman eleman sayısına eşittir, yani çalışma zamanında sürekli değişebilir.
Bellek alanı / Fiziksel olarak ardışık bellek alanı gerekir. / Bellekte dağınık bir şekilde yerleşebilir.
Elemanların sırası / Dizinin indeks numarası ile tüm elemanlara erişilebilir. / Bir sonraki elemanın bellek adresi bilgisi bir önceki eleman tarafından tutulur.

Fonksiyon / Dizi / Bağlı liste (Tablo)

createStack() / Eleman sayısı belli olan yığın tanımlanır. / Yığın kökü işaretçisi tanımlanır.
isFull() / Üst elemanı tutan değişken ile yığın boyutu eşitse yığın doludur. / Bağlı liste ile oluşturulan yığının boyutu önceden belirtilmediyse, yığın boyutu bellek boyutu ile sınırlıdır. Bu durumda isFull() fonksiyonu kullanılamaz.
push() / Yığın dolu değilse üst değeri 1 arttırılır ve üst indeks numaralı alana yeni eleman eklenir. / Yığın sonuna yeni düğüm eklenir ve üst işaretçisi yeni elemanın adresine kaydırılır.
isEmpty() / Üst değişkeninin değeri -1 ise yığın boştur. / Üst işaretçisi ile kök işaretçisi eşitse yığın boştur.
peek() / Üst indeks numaralı veri yazdırılır. / Üst işaretcisinin gösterdiği düğüm yazdırılır.
display() / İndeks numarası üst elemandan başlayıp sıfıra doğru ilerleyerek tüm yığın elemanları yazdırılır. / Tek yönlü bağlı liste için kökten üst işaretçisine doğru ilerleyerek, çift yönlü bağlı liste için kökten üste veya üstten köke doğru ilerleyerek yığın yazdırılır.
pop() / İndeks numarası üst değişkeninin değeri olan eleman silinir ve üst değeri 1 azaltılır. / Son düğüm silinir ve üst işaretçisi bir önceki düğüme kaydırılır. Tek yönlü bağlı liste için işlem yükü fazladır.
